/* @formatter:off * * Dave Rosenberg * Comp 2000 - Data Structures * Demonstration: Bag ADT * Fall, 2021 *  * Usage restrictions: *  * You may use this code for exploration, experimentation, and furthering your * learning for this course. You may not use this code for any other * assignments, in my course or elsewhere, without explicit permission, in * advance, from myself (and the instructor of any other course). *  * Further, you may not post nor otherwise share this code with anyone other than * current students in my sections of this course. Violation of these usage * restrictions will be considered a violation of the Wentworth Institute of * Technology Academic Honesty Policy. * * Do not remove this notice. * * @formatter:on */package bag.fixed_size_array.version1 ;import bag.BagInterface ;/** * A class of bags whose entries are stored in a fixed-size array. INITIAL, * INCOMPLETE DEFINITION; no security checks *  * @version 5.0 * @author Frank M. Carrano * @param <T> *     The class of object the Bag will hold
 */public final class ArrayBag<T> implements BagInterface<T>    {    private final T[] bag ;    private int numberOfEntries ;        private static final int DEFAULT_CAPACITY = 25 ;    /** Creates an empty bag whose capacity is 25. */    public ArrayBag()        {        this( DEFAULT_CAPACITY ) ;                } // end no-arg constructor    /**     * Creates an empty bag having a given capacity.     *      * @param desiredCapacity     *     The integer capacity desired.     */    public ArrayBag( final int desiredCapacity )        {        // The cast is safe because the new array contains null entries        @SuppressWarnings( "unchecked" )        final T[] tempBag = (T[]) new Object[ desiredCapacity ] ;        this.bag = tempBag ;                this.numberOfEntries = 0 ;                } // end 1-arg constructor    /**     * Adds a new entry to this bag.     *      * @param newEntry     *     The object to be added as a new entry.     * @return true if the addition is successful, or false if not.     */    public boolean add( final T newEntry )        {        boolean result = true ;     // typically we will succeed                if ( isArrayFull() )            {            result = false ;        // no room            }        else            {  // Assertion: result is true here            this.bag[ this.numberOfEntries ] = newEntry ;            this.numberOfEntries++ ;            } // end if        return result ;                } // end add()    /**     * Retrieves all entries that are in this bag.     *      * @return A newly allocated array of all the entries in this bag.     */    public T[] toArray()        {        // The cast is safe because the new array contains null entries.        @SuppressWarnings( "unchecked" )        final T[] result = (T[]) new Object[ this.numberOfEntries ] ;        for ( int index = 0 ; index < this.numberOfEntries ; index++ )            {            result[ index ] = this.bag[ index ] ;            } // end for        return result ;                // Note: The body of this method could consist of one return statement,        // if you call Arrays.copyOf                } // end toArray()    // Returns true if the array bag is full, or false if not.    private boolean isArrayFull()        {        return this.numberOfEntries == this.bag.length ;                } // end isArrayFull()// STUBS:    /**     * Sees whether this bag is empty.     *      * @return true if this bag is empty, or false if not     */    public boolean isEmpty()        {        return false ; // STUB                } // end isEmpty()    /**     * Gets the number of entries currently in this bag.     *      * @return The integer number of entries currently in this bag     */    public int getCurrentSize()        {        return -1 ; // STUB                } // end getCurrentSize()    /**     * Removes one unspecified entry from this bag, if possible.     *      * @return Either the removed entry, if the removal was successful, or null     */    public T remove()        {        return null ; // STUB                } // end remove()    /**     * Removes one occurrence of a given entry from this bag.     *      * @param anEntry     *     The entry to be removed     * @return true if the removal was successful, or false otherwise     */    public boolean remove( final T anEntry )        {        return false ; // STUB                } // end remove()    /** Removes all entries from this bag. */    public void clear()        {        // STUB                } // end clear()    /**     * Counts the number of times a given entry appears in this bag.     *      * @param anEntry     *     The entry to be counted     * @return The number of times anEntry appears in the bag     */    public int getFrequencyOf( final T anEntry )        {        return -1 ; // STUB                } // end getFrequencyOf()    /**     * Tests whether this bag contains a given entry.     *      * @param anEntry     *     The entry to locate     * @return true if this bag contains anEntry, or false otherwise     */    public boolean contains( final T anEntry )        {        return false ; // STUB                } // end contains()        } // end class ArrayBag